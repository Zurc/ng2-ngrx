import 'rxjs/add/observable/empty';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/switchMapTo';
import 'rxjs/add/operator/takeUntil';
import 'rxjs/add/operator/share';
import { Observable } from 'rxjs/Observable';
import { OpaqueToken, Inject, Injectable } from '@angular/core';
import { ActionTypes } from './actions';
import { unliftState, unliftAction } from './utils';
export var ExtensionActionTypes = {
    START: 'START',
    DISPATCH: 'DISPATCH',
    STOP: 'STOP',
    ACTION: 'ACTION'
};
export var REDUX_DEVTOOLS_EXTENSION = new OpaqueToken('Redux Devtools Extension');
export var DevtoolsExtension = (function () {
    function DevtoolsExtension(devtoolsExtension) {
        this.instanceId = "ngrx-store-" + Date.now();
        this.devtoolsExtension = devtoolsExtension;
        this.createActionStreams();
    }
    DevtoolsExtension.prototype.notify = function (action, state) {
        if (!this.devtoolsExtension || action.type !== ActionTypes.PERFORM_ACTION) {
            return;
        }
        this.devtoolsExtension.send(unliftAction(state), unliftState(state), false, this.instanceId);
        this.devtoolsExtension.send(null, state, false, this.instanceId);
    };
    DevtoolsExtension.prototype.createChangesObservable = function () {
        var _this = this;
        if (!this.devtoolsExtension) {
            return Observable.empty();
        }
        return new Observable(function (subscriber) {
            var connection = _this.devtoolsExtension.connect({ instanceId: _this.instanceId });
            connection.subscribe(function (change) { return subscriber.next(change); });
            return connection.unsubscribe();
        });
    };
    DevtoolsExtension.prototype.createActionStreams = function () {
        // Listens to all changes based on our instanceId
        var changes$ = this.createChangesObservable().share();
        // Listen for the start action
        var start$ = changes$
            .filter(function (change) { return change.type === ExtensionActionTypes.START; });
        // Listen for the stop action
        var stop$ = changes$
            .filter(function (change) { return change.type === ExtensionActionTypes.STOP; });
        // Listen for lifted actions
        var liftedActions$ = changes$
            .filter(function (change) { return change.type === ExtensionActionTypes.DISPATCH; })
            .map(function (change) { return change.payload; });
        // .filter(action => action.type !== 'JUMP_TO_STATE');
        // Listen for unlifted actions
        var actions$ = changes$
            .filter(function (change) { return change.type === ExtensionActionTypes.DISPATCH; })
            .map(function (change) { return change.payload; });
        // Only take the action sources between the start/stop events
        this.actions$ = start$.switchMapTo(actions$.takeUntil(stop$));
        this.liftedActions$ = start$.switchMapTo(liftedActions$.takeUntil(stop$));
    };
    /** @nocollapse */
    DevtoolsExtension.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DevtoolsExtension.ctorParameters = [
        { type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION,] },] },
    ];
    return DevtoolsExtension;
}());
